import { ParseTree } from '@mliebelt/pgn-parser';
import { Field, PROMOTIONS_SHORT, PgnGame, PgnReaderMove, PgnMove, Tags, GameComment } from '@mliebelt/pgn-types';
export { Field, GameComment, PROMOTIONS, PgnReaderMove } from '@mliebelt/pgn-types';

type PrimitiveMove = {
    from: Field;
    to: Field;
    promotion?: PROMOTIONS_SHORT;
};
type PgnReaderConfiguration = {
    mode?: string;
    notation?: 'short' | 'long';
    position?: 'start' | string;
    locale?: string;
    lazyLoad?: boolean;
    manyGames?: boolean;
    pgn?: string;
    pgnFile?: string;
    startPlay?: number | string;
    hideMovesBefore?: boolean;
};
type Shape = {
    brush: string;
    orig: Field;
    dest?: Field;
};
type FEN = string;
type SAN = string;

/**
 * Interface representing the state of a game.
 * Contains the PgnGame representing the full game.
 * The idea is to have some functions to return parts of the state of the game.
 * Playing a game is mostly moving through the tree of moves. For editing, more functions are needed.
 */
interface GameState {
    game: PgnGame;
    currentMove?: PgnReaderMove | undefined;
}

declare const NAGs: any[];
declare const PGN_NAGS: {};
/**
 * Returns the NAG notation from the array of symbols
 * @param array the NAG symbols like $1, $3, ...
 * @returns {string} the result string like !, !!
 */
declare function nagToSymbol(array: any): string;
/**
 * Returns the SYM notation for a single NAG (like !!, ?!, ...)
 * @param string the NAG in the chess notation
 * @returns {*} the symbold like $0, $3, ...
 */
declare function symbolToNag(string: any): string | null;
declare function hasDiagramNag(move: any): boolean;

/**
 * Defines the base functionality for reading and working with PGN.
 * The configuration is the part of the configuration given to the PgnViewer that is relevant
 * for the reader.
 * The reader is an abstraction that just knows the current games, and handles changes by keeping the change
 * in the state of the game. So all local storage in the reader should be avoided besides `configuration`, `games`
 * and `currentGameIndex`.
 * @param {*} configuration Given values are relevant for reading and working with PGN
 */
declare class PgnReader {
    configuration: PgnReaderConfiguration;
    games: ParseTree[];
    checkedGames?: PgnGame[];
    moves: PgnReaderMove[];
    chess: any;
    currentGameIndex: number;
    endGame: string;
    constructor(configuration: PgnReaderConfiguration);
    /**
     * Returns the real notation from the move (excluding NAGs).
     * @param move given move in JSON notation
     * @return {*} the SAN string created from the move
     */
    san(move: PgnReaderMove): string;
    sanWithNags(move: PgnReaderMove): string;
    loadPgn(): PgnReader;
    loadMany(): void;
    loadOne(game: ParseTree | number): void;
    getGame(index: number): PgnGame;
    possibleMoves(move: number | string): Map<Field, Field[]>;
    readMoves(moves: PgnMove[]): void;
    isMove(id: number): boolean;
    isDeleted(id: number): boolean;
    getMove(id: number): PgnReaderMove | undefined;
    deleteMove(id: number): void;
    updateVariationLevel(move: PgnReaderMove, varLevel: number): void;
    findMove(moveRep: number | string): PgnReaderMove | undefined;
    deleteMovesBefore(moveRep: number | string): string;
    promoteMove(id: number): void;
    startMainLine(move: PgnReaderMove): boolean;
    startVariation(move: PgnReaderMove): boolean;
    endVariation(move: PgnReaderMove): boolean;
    afterMoveWithVariation(move: PgnReaderMove): boolean;
    writePgn(configuration?: {}): string;
    /**
     * Sets the position to the start position, depending on the configuration. Returns the resulting position as FEN string.
     * @return string The position as FEN string
     */
    setToStart(): string;
    eachMove(movesMainLine: PgnMove[]): void;
    addMove(move: PrimitiveMove | string, moveNumber: number): number;
    changeNag(_nag: string, moveNumber: number, added: boolean): void;
    clearNags(moveNumber: number): void;
    getOrderedMoves(current: PgnReaderMove, returnedMoves: PgnReaderMove[]): PgnReaderMove[];
    getMoves(): PgnReaderMove[];
    getFirstMove(): PgnReaderMove | null;
    getTags(): Tags;
    getGameComment(): GameComment;
    getGames(): ParseTree[];
    getEndGame(): string;
    getPosition(index: number | null): FEN;
    setShapes(move: PgnReaderMove, shapes: Shape[]): void;
    gameState: GameState;
    makeMove(move?: PgnReaderMove | SAN): boolean;
    setPosition(position: FEN): boolean;
    loadGame(game: PgnGame): void;
}

declare class StringBuilder {
    strings: Array<string>;
    constructor(value: string);
    append(value: any): StringBuilder;
    isEmpty(): boolean;
    lastChar(): string;
    toString(): string;
}

interface ViewApi {
    gameState: GameState;
    makeMove(move?: PgnReaderMove | SAN): GameState;
    setPosition(position: FEN): GameState;
    getCurrentPosition(): FEN;
    getMoves(): PgnReaderMove[];
}
/**
 * Read a PGN string and return the game.
 * @param pgn the PGN string to read.
 */
declare function read(pgn: string): PgnGame;
/**
 * Read a PGN string and return the games read as array.
 * @param pgn the PGN string to read.
 */
declare function readMany(pgn: string): PgnGame[];
declare function view(game: PgnGame, configuration: PgnReaderConfiguration): ViewApi;

export { type FEN, NAGs, PGN_NAGS, PgnReader, type PgnReaderConfiguration, type PrimitiveMove, type SAN, type Shape, StringBuilder, type ViewApi, hasDiagramNag, nagToSymbol, read, readMany, symbolToNag, view };
