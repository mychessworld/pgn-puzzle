(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.PgnWriter = {}));
})(this, (function (exports) { 'use strict';

    const writeGame = function (game, configuration = {}) {
        return writePgn(game, configuration);
    };
    /**
     * Writes the pgn (fully) of the current game. The algorithm goes like that:
     * * Start with the first move (there has to be only one in the main line)
     * * For each move (call that recursively)
     * * print-out the move itself
     * * then the variations (one by one)
     * * then the next move of the main line
     * @return the string of all moves
     */
    const writePgn = function (game, configuration) {
        function getGameComment(game) {
            return game.gameComment ? game.gameComment.comment : undefined;
        }
        const startVariation = function (move) {
            return move.variationLevel !== undefined && move.variationLevel > 0 &&
                ((typeof move.prev != "number") || (game.moves[move.prev].next !== move.index));
        };
        const firstMove = function (move) {
            return typeof move.prev != "number";
        };
        const getMove = function (index) {
            return game.moves[index];
        };
        // Prepend a space if necessary
        function prependSpace(sb) {
            if ((!sb.isEmpty()) && (sb.lastChar() !== " ") && (sb.lastChar() !== "\n")) {
                sb.append(" ");
            }
        }
        const writeComment = function (comment, sb) {
            if (comment === undefined || comment === null) {
                return;
            }
            prependSpace(sb);
            sb.append("{");
            sb.append(comment);
            sb.append("}");
        };
        const writeGameComment = function (game, sb) {
            writeComment(getGameComment(game), sb);
        };
        const writeCommentMove = function (move, sb) {
            writeComment(move.commentMove, sb);
        };
        const writeCommentAfter = function (move, sb) {
            writeComment(move.commentAfter, sb);
        };
        const writeCommentDiag = function (move, sb) {
            let has_diags = (move) => {
                return move.commentDiag &&
                    ((move.commentDiag.colorArrows && move.commentDiag.colorArrows.length > 0) ||
                        (move.commentDiag.colorFields && move.commentDiag.colorFields.length > 0));
            };
            let arrows = (move) => { return move.commentDiag.colorArrows || []; };
            let fields = (move) => { return move.commentDiag.colorFields || []; };
            if (has_diags(move)) {
                let sbdiags = new StringBuilder();
                let first = true;
                sbdiags.append("[%csl ");
                fields(move).forEach((field) => {
                    !first ? sbdiags.append(",") : sbdiags.append("");
                    first = false;
                    sbdiags.append(field);
                });
                sbdiags.append("]");
                first = true;
                sbdiags.append("[%cal ");
                arrows(move).forEach((arrow) => {
                    !first ? sbdiags.append(",") : sbdiags.append("");
                    first = false;
                    sbdiags.append(arrow);
                });
                sbdiags.append("]");
                writeComment(sbdiags.toString(), sb);
            }
        };
        const writeMoveNumber = function (move, sb) {
            prependSpace(sb);
            if (move.turn === "w") {
                sb.append("" + move.moveNumber);
                sb.append(".");
            }
            else if (firstMove(move) || startVariation(move)) {
                sb.append("" + move.moveNumber);
                sb.append("...");
            }
        };
        const writeNotation = function (move, sb) {
            function san(move) {
                function getFig(fig) {
                    if (fig === 'P') {
                        return '';
                    }
                    return fig;
                }
                let notation = move.notation;
                if (notation.notation && configuration.notation != 'long') { // notation is filled, no need to try to compute it again
                    return notation.notation; // move like O-O and O-O-O
                }
                const fig = notation.fig ? getFig(notation.fig) : '';
                let disc = notation.disc ? notation.disc : '';
                const strike = notation.strike ? notation.strike : '';
                // Pawn moves with capture need the col as "discriminator"
                if (strike && !fig) { // Pawn capture
                    disc = move.from.substring(0, 1);
                }
                const check = notation.check ? notation.check : '';
                const prom = notation.promotion ? '=' + getFig(notation.promotion.substring(1, 2)) : '';
                if (configuration.notation === 'long') {
                    return fig + move.from + (notation.strike ? strike : '-') + move.to + prom + check;
                }
                return fig + disc + strike + notation.col + notation.row + prom + check;
            }
            prependSpace(sb);
            sb.append(san(move));
        };
        const writeNAGs = function (move, sb) {
            if (move.nag) {
                move.nag.forEach(function (ele) {
                    sb.append(ele);
                });
            }
        };
        const writeVariation = function (move, sb) {
            prependSpace(sb);
            sb.append("(");
            writeMove(move, sb);
            prependSpace(sb);
            sb.append(")");
        };
        const writeVariations = function (move, sb) {
            for (let i = 0; i < move.variations.length; i++) {
                writeVariation(move.variations[i], sb);
            }
        };
        const getNextMove = function (move) {
            return move.next ? getMove(move.next) : null;
        };
        /**
         * Write the normalised notation: comment move, move number (if necessary),
         * comment before, move, NAGs, comment after, variations.
         * Then go into recursion for the next move.
         * @param move the move in the exploded format
         * @param sb the string builder to use
         */
        const writeMove = function (move, sb) {
            if (move === null || move === undefined) {
                return;
            }
            writeCommentMove(move, sb);
            writeMoveNumber(move, sb);
            writeNotation(move, sb);
            //write_check_or_mate(move, sb)    // not necessary if san from chess.src is used
            writeNAGs(move, sb);
            writeCommentAfter(move, sb);
            writeCommentDiag(move, sb);
            writeVariations(move, sb);
            const next = getNextMove(move);
            writeMove(next, sb);
        };
        const writeEndGame = function (game, sb) {
            if ((game.tags !== undefined) && ('Result' in game.tags)) {
                prependSpace(sb);
                sb.append(game.tags['Result']);
            }
        };
        function writeTags(game, sb) {
            function writeTag(key, value, _sb) {
                if (value) {
                    let _v;
                    if (typeof value === "string") {
                        if (value.length > 0) {
                            _v = value;
                        }
                        else {
                            return;
                        }
                    }
                    else if (typeof value === "object") {
                        _v = value.value;
                    }
                    else {
                        _v = value;
                    }
                    _sb.append('[').append(key).append(' ').append('"').append(_v).append('"').append("]\n");
                }
            }
            function consumeTag(key, tags, _sb) {
                writeTag(key, tags.get(key), _sb);
                tags.delete(key);
            }
            if (configuration.tags && (configuration.tags == "no")) {
                return;
            }
            if ((game.tags) && (Object.keys(game.tags).length)) {
                let _tags = new Map(Object.entries(game.tags));
                _tags.delete("messages"); // workaround for internal working of pgn-parser
                "Event Site Date Round White Black Result".split(' ').forEach(value => consumeTag(value, _tags, sb));
                _tags.forEach(function (value, key) {
                    writeTag(key, value, sb);
                });
                sb.append("\n");
            }
        }
        const writePgn2 = function (game, move, sb) {
            writeTags(game, sb);
            writeGameComment(game, sb);
            writeMove(move, sb);
            writeEndGame(game, sb);
            return sb.toString();
        };
        const sb = new StringBuilder();
        let indexFirstMove = 0;
        return writePgn2(game, getMove(indexFirstMove), sb);
    };
    // Initializes a new instance of the StringBuilder class
    // and appends the given value if supplied
    class StringBuilder {
        strings = new Array("");
        constructor(value = "") {
            this.append(value);
        }
        // Appends the given value to the end of this instance.
        append(value) {
            if (!value) {
                return this;
            }
            if (typeof value === "string") {
                this.strings.push(value);
            }
            else {
                this.strings.push(value.toString());
            }
            return this;
        }
        // Return true if the receiver is empty. Don't compute length!!
        isEmpty() {
            for (let i = 0; i < this.strings.length; i++) {
                if (this.strings[i].length > 0) {
                    return false;
                }
            }
            return true;
        }
        // Return the last character (as string) of the receiver.
        // Return null if none is found
        lastChar() {
            if (this.strings.length === 0) {
                return null;
            }
            return this.strings[this.strings.length - 1].slice(-1);
        }
        // Converts this instance to a String.
        toString() {
            return this.strings.join("");
        }
    }

    const PROMOTIONS = {
        'q': 'queen',
        'r': 'rook',
        'b': 'bishop',
        'n': 'knight'
    };
    const prom_short = ['q', 'r', 'b', 'n'];
    const colors = ['white', 'black'];
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];

    exports.PROMOTIONS = PROMOTIONS;
    exports.StringBuilder = StringBuilder;
    exports.colors = colors;
    exports.files = files;
    exports.prom_short = prom_short;
    exports.ranks = ranks;
    exports.writeGame = writeGame;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
